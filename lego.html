<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Lego Tech Fest 2025 — Convertite en Lego</title>
<style>
  /* Minimal styles (puedes usar los tuyos). */
  body{font-family:Arial,Helvetica,sans-serif;background:#071026;color:#e9eef8;min-height:100vh;margin:0;display:flex;align-items:center;justify-content:center}
  .card{width:96%;max-width:900px;background:#07142a;padding:22px;border-radius:12px;box-shadow:0 10px 40px rgba(0,0,0,0.6)}
  video, img{width:100%;border-radius:10px;display:block}
  .row{display:flex;gap:12px;margin-top:12px}
  button{padding:10px 14px;border-radius:8px;border:none;background:#00d4ff;color:#061223;font-weight:700;cursor:pointer}
  .muted{color:#9fb0d8;font-size:0.9rem}
  .hidden{display:none}
  input{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:#061026;color:#eaf2ff}
  .notice{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;margin-top:10px}
</style>
</head>
<body>
  <div class="card">
    <h2>Lego Tech Fest — Convertite con la IA</h2>

    <div id="stage-capture">
      <div style="background:#000;border-radius:8px;overflow:hidden">
        <video id="webcam" autoplay playsinline muted style="transform:scaleX(-1);height:360px;object-fit:cover"></video>
      </div>
      <div class="row">
        <button id="captureBtn">Tomar foto</button>
        <button id="backBtn" style="background:transparent;color:#e9eef8;border:1px solid rgba(255,255,255,0.06)">Volver</button>
      </div>
      <p class="muted">La imagen será enviada a la IA remota. Asegurate de tener la variable WORDWARE_API_KEY configurada en Netlify.</p>
      <div id="capture-msg" class="notice hidden"></div>
    </div>

    <div id="stage-processing" class="hidden">
      <div class="notice" id="processingText">Enviando a la IA...</div>
    </div>

    <div id="stage-preview" class="hidden">
      <h3>Previsualización</h3>
      <img id="previewImg" alt="preview" />
      <div style="margin-top:10px;display:flex;gap:8px">
        <input id="fileName" placeholder="nombre (ej: juan_legovip)" />
        <button id="saveBtn" disabled>Guardar</button>
        <button id="retakeBtn" style="background:transparent;color:#e9eef8;border:1px solid rgba(255,255,255,0.06)">Volver a tomar</button>
      </div>
      <div id="serverInfo" class="muted notice hidden"></div>
    </div>

    <div id="stage-final" class="hidden">
      <h3>Guardado</h3>
      <img id="finalImg" alt="final" />
      <div style="margin-top:10px">
        <button id="finishBtn">Finalizar</button>
      </div>
    </div>

  </div>

<script>
// Elements
const webcam = document.getElementById('webcam');
const captureBtn = document.getElementById('captureBtn');
const backBtn = document.getElementById('backBtn');
const captureMsg = document.getElementById('capture-msg');
const stageCapture = document.getElementById('stage-capture');
const stageProcessing = document.getElementById('stage-processing');
const stagePreview = document.getElementById('stage-preview');
const stageFinal = document.getElementById('stage-final');
const processingText = document.getElementById('processingText');
const previewImg = document.getElementById('previewImg');
const finalImg = document.getElementById('finalImg');
const fileNameInput = document.getElementById('fileName');
const saveBtn = document.getElementById('saveBtn');
const retakeBtn = document.getElementById('retakeBtn');
const serverInfo = document.getElementById('serverInfo');
const finishBtn = document.getElementById('finishBtn');

let stream=null, lastDataUrl=null, capturedBlob=null;

// Start webcam
async function startCamera(){
  try{
    stream = await navigator.mediaDevices.getUserMedia({ video: { width:1280, height:720 }, audio:false });
    webcam.srcObject = stream;
  }catch(e){
    console.error('Camera start failed', e);
    captureMsg.textContent = 'No se pudo acceder a la cámara: ' + (e.message || e);
    captureMsg.classList.remove('hidden');
  }
}
startCamera();

function showStage(stage){
  [stageCapture, stageProcessing, stagePreview, stageFinal].forEach(s => s.classList.add('hidden'));
  stage.classList.remove('hidden');
}

// Capture frame and process (resize+compress) -> blob
async function captureFrame(){
  const videoTrack = stream?.getVideoTracks?.()[0];
  if(!videoTrack){ throw new Error('No video track'); }
  const canvas = document.createElement('canvas');
  canvas.width = webcam.videoWidth || 1280;
  canvas.height = webcam.videoHeight || 720;
  const ctx = canvas.getContext('2d');
  // mirror to preserve user's view
  ctx.translate(canvas.width, 0);
  ctx.scale(-1, 1);
  ctx.drawImage(webcam, 0, 0, canvas.width, canvas.height);

  // original as PNG then compress by resizing to max 1024 width and JPEG quality 0.82
  const blob = await new Promise(res => canvas.toBlob(res, 'image/png'));
  const processed = await resizeAndCompressBlob(blob, { maxWidth: 1024, quality: 0.82 });
  return processed;
}

async function resizeAndCompressBlob(blob, { maxWidth = 1024, quality = 0.82 } = {}){
  const bitmap = await createImageBitmap(blob);
  let w = bitmap.width, h = bitmap.height;
  if(w > maxWidth){
    const scale = maxWidth / w;
    w = Math.round(w * scale);
    h = Math.round(h * scale);
  }
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  const ctx = c.getContext('2d');
  ctx.drawImage(bitmap, 0, 0, w, h);
  const outBlob = await new Promise(res => c.toBlob(res, 'image/jpeg', quality));
  bitmap.close?.();
  return outBlob;
}

async function blobToBase64(blob){
  return new Promise((resolve, reject) => {
    const r = new FileReader();
    r.onload = () => {
      if(typeof r.result === 'string'){
        const parts = r.result.split(',');
        if(parts.length >= 2) resolve(parts[1]);
        else reject(new Error('Invalid data URL from FileReader'));
      } else reject(new Error('FileReader result not string'));
    };
    r.onerror = (e) => reject(e || new Error('FileReader error'));
    r.readAsDataURL(blob);
  });
}

// POST to serverless with retries client-side
async function postToServer(base64, maxAttempts = 2){
  const url = '/.netlify/functions/generate-lego';
  let attempt = 0;
  let lastErr = null;
  for(attempt = 1; attempt <= maxAttempts; attempt++){
    try {
      processingText.textContent = `Enviando a IA (intentando ${attempt}/${maxAttempts})...`;
      const controller = new AbortController();
      const timeout = setTimeout(()=>controller.abort(), 60_000);
      const resp = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ image_base64: base64 }),
        signal: controller.signal
      });
      clearTimeout(timeout);

      const text = await resp.text().catch(()=>null);
      let json = null;
      try { json = text ? JSON.parse(text) : null; } catch(e){ json = null; }

      if(!resp.ok){
        console.warn('[client] server returned non-ok', resp.status, text);
        lastErr = { status: resp.status, text };
        // if 5xx or 429 -> retry
        if(resp.status >= 500 || resp.status === 429){
          if(attempt < maxAttempts) await new Promise(r => setTimeout(r, 1000 * attempt));
          continue;
        } else {
          throw new Error('Server error: ' + text);
        }
      }

      return json || {};
    } catch (e){
      lastErr = e;
      console.error('[client] postToServer attempt failed', attempt, e);
      if(attempt < maxAttempts) await new Promise(r => setTimeout(r, 1000 * attempt));
    }
  }
  throw lastErr;
}

// main capture flow
captureBtn.addEventListener('click', async ()=>{
  try{
    showStage(stageProcessing);
    const processedBlob = await captureFrame();
    capturedBlob = processedBlob;

    // convert base64
    const base64 = await blobToBase64(processedBlob);

    // call server
    const serverResp = await postToServer(base64, 3).catch(err=>{
      throw err;
    });

    // serverResp expected: { result_url: "...", data_url: "data:...;base64,..." }
    if(serverResp && serverResp.data_url){
      lastDataUrl = serverResp.data_url;
      previewImg.src = lastDataUrl;
      serverInfo.textContent = `Servidor: OK (result_url: ${serverResp.result_url || 'n/a'})`;
      serverInfo.classList.remove('hidden');
      showStage(stagePreview);
      fileNameInput.value = '';
      saveBtn.disabled = true;
      return;
    } else if(serverResp && serverResp.result_url){
      // server provided only result_url: attempt to fetch it client-side (may cause CORS failure)
      try {
        const r = await fetch(serverResp.result_url);
        if(!r.ok) throw new Error('HTTP ' + r.status);
        const b = await r.blob();
        const reader = new FileReader();
        reader.onload = () => {
          lastDataUrl = reader.result;
          previewImg.src = lastDataUrl;
          serverInfo.textContent = `Servidor: OK (fetched result_url)`;
          serverInfo.classList.remove('hidden');
          showStage(stagePreview);
          fileNameInput.value = '';
          saveBtn.disabled = true;
        };
        reader.onerror = (e) => { throw e || new Error('FileReader failed'); };
        reader.readAsDataURL(b);
        return;
      } catch (e) {
        console.error('[client] failed to download result_url (likely CORS):', e);
        throw new Error('El servidor devolvió una URL que no se pudo descargar desde el cliente (CORS). Pegá aquí el JSON de respuesta del servidor para que lo revise.');
      }
    } else {
      console.error('[client] unexpected server response', serverResp);
      throw new Error('Respuesta inesperada del servidor: ' + JSON.stringify(serverResp).slice(0,1000));
    }

  } catch (err){
    console.error('Error en flujo IA:', err);
    // show friendly message + raw error
    showStage(stageCapture);
    captureMsg.textContent = 'Error generando la imagen: ' + (err?.message || err);
    captureMsg.classList.remove('hidden');
    // also reveal server response details in console (so user can paste)
    console.error('Por favor copia el log de consola y el JSON de la respuesta del servidor (si existe).');
  }
});

// Save / download
saveBtn.addEventListener('click', async ()=>{
  if(!lastDataUrl) return alert('No hay imagen para guardar');
  let name = (fileNameInput.value || '').trim();
  if(!name) { alert('Ingresá un nombre'); fileNameInput.focus(); return; }
  name = name.replace(/[^a-z0-9_\-]/gi,'_').toLowerCase();

  try {
    const res = await fetch(lastDataUrl);
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = name + '.png';
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
    finalImg.src = lastDataUrl;
    showStage(stageFinal);
  } catch (e){
    console.error('Save failed', e);
    alert('Error descargando la imagen: ' + (e?.message || e));
  }
});

fileNameInput.addEventListener('input', ()=> saveBtn.disabled = !fileNameInput.value.trim());
retakeBtn.addEventListener('click', ()=> { lastDataUrl = null; capturedBlob = null; showStage(stageCapture); });
finishBtn.addEventListener('click', ()=> location.href = 'index.html');
backBtn.addEventListener('click', ()=> location.href = 'index.html');

</script>
</body>
</html>
