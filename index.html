<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Lego Tech Fest 2025 — Convertite en Lego</title>
<!-- (el CSS es igual al anterior; lo mantengo sin cambios funcionales) -->
<style>
/* ... el mismo CSS que venías usando ... */
:root { font-size:16px; }
*{box-sizing:border-box;margin:0;padding:0}
html,body{height:100%}
body{
  font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;
  background:radial-gradient(1200px 600px at 10% 10%, rgba(0,212,255,0.035), transparent),
             linear-gradient(135deg,#0f1121 0%, #2b2340 100%);
  color:#e9eef8; display:flex; flex-direction:column; min-height:100vh; overflow-x:hidden;
  -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
}
header,footer{
  background:rgba(0,0,0,0.15);backdrop-filter:blur(6px);padding:14px 16px;text-align:center;
  box-shadow:0 8px 30px rgba(0,0,0,0.45)
}
header h1{font-size:1.1rem;letter-spacing:1px}
footer p{font-size:0.85rem;color:#bfc8df}

/* ... resto del CSS ... */
.card{
  width:100%; max-width:980px; border-radius:16px; padding:26px;
  background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.008));
  box-shadow:0 18px 60px rgba(2,6,23,0.6); position:relative; overflow:hidden;
  transform: scale(0.98) translateY(8px) rotate(-0.4deg); opacity:0;
  animation:cardIntro 0.9s cubic-bezier(.2,.9,.3,1) forwards;
}
/* (el CSS completo lo mantenés igual al anterior) */
</style>
</head>
<body>
<header><h1>Lego Tech Fest 2025</h1></header>
<main>
  <div class="card" id="card">
    <button class="floating-back" id="backToIndex" title="Volver al inicio">←</button>

    <section id="sceneWebcam" class="scene active center-col">
      <div id="webcamPreview" aria-label="Vista previa de la cámara">
        <video id="webcamVideo" autoplay playsinline muted></video>
        <div id="counter" aria-hidden="true">5</div>
        <div id="flash" class="hidden" aria-hidden="true"></div>
      </div>
      <div style="display:flex;gap:12px;align-items:center;justify-content:center;margin-top:12px;">
        <button id="btnCapture" class="btn large">Tomar foto</button>
      </div>
      <p class="muted">Presioná "Tomar foto". El contador aparecerá y te avisará cuándo.</p>
    </section>

    <section id="sceneProcessing" class="scene center-col">
      <div class="processing-area">
        <div class="processing-box" aria-hidden="true">
          <div style="display:flex;align-items:center;justify-content:center;">
            <div class="brick" style="background:#ff6ec7"></div>
            <div class="brick" style="background:#00d4ff; animation-delay:.12s"></div>
            <div class="brick" style="background:#ffd166; animation-delay:.24s"></div>
          </div>
        </div>
        <div style="text-align:center">
          <div class="muted" id="processingText">Generando tu versión Lego... aguarda un instante</div>
        </div>
      </div>
    </section>

    <section id="scenePreview" class="scene center-col">
      <img id="legoPreview" alt="Previsualización Lego" />
      <div style="display:flex;flex-direction:column;align-items:center;gap:10px;width:100%;">
        <input id="nameInput" type="text" placeholder="Elegí un nombre único (ej: juan_legovip)" />
        <div style="display:flex;gap:10px;align-items:center;">
          <button id="btnSave" class="btn large" disabled>Guardar</button>
          <button id="btnRetake" class="btn ghost">Volver a tomar</button>
        </div>
        <div class="muted" id="nameHint">El nombre será usado para el archivo descargado.</div>
      </div>
    </section>

    <section id="sceneFinal" class="scene center-col">
      <h2>¡Listo! Tu Lego está guardado.</h2>
      <img id="finalPreview" alt="Resultado final" />
      <button id="btnFinal" class="btn large">Finalizar</button>
    </section>

  </div>
</main>
<footer><p>Tech Fest 2025. Creado por Juan Bautista Fabris Rico y Francisco Farina</p></footer>

<script>
/* ---------- Helpers & UI ---------- */
const scenes = {
  webcam: document.getElementById('sceneWebcam'),
  processing: document.getElementById('sceneProcessing'),
  preview: document.getElementById('scenePreview'),
  final: document.getElementById('sceneFinal')
};
function showScene(key){
  Object.values(scenes).forEach(s => { s.classList.remove('active'); s.style.display='none'; });
  const el = scenes[key]; el.style.display = 'flex';
  requestAnimationFrame(()=>el.classList.add('active'));
}
document.getElementById('backToIndex').onclick = ()=> window.location.href='index.html';

const video = document.getElementById('webcamVideo');
const counter = document.getElementById('counter');
const flash = document.getElementById('flash');
const btnCapture = document.getElementById('btnCapture');
const btnRetake = document.getElementById('btnRetake');
const btnSave = document.getElementById('btnSave');
const nameInput = document.getElementById('nameInput');
const legoPreview = document.getElementById('legoPreview');
const finalPreview = document.getElementById('finalPreview');
const btnFinal = document.getElementById('btnFinal');

let stream=null, capturedBlob=null, legoBlob=null, legoDataUrl=null, counting=false;

/* Start webcam */
async function startWebcam(){
  try{
    stream = await navigator.mediaDevices.getUserMedia({video:{width:1280,height:720},audio:false});
    video.srcObject=stream;
  }catch(err){ alert('No se pudo acceder a la cámara: '+err.message); }
}
startWebcam();

/* Counter & capture UI */
function showCounter(val){ counter.textContent=val; counter.classList.add('counter-show'); counter.classList.remove('hidden'); }
function hideCounter(){ counter.classList.remove('counter-show'); setTimeout(()=>counter.classList.add('hidden'),160); }
function cameraShake(){ const c=document.getElementById('card'); c.style.transition='transform .2s'; c.style.transform='translateX(-6px)'; setTimeout(()=>c.style.transform='translateX(6px)',80); setTimeout(()=>c.style.transform='translateX(-3px)',160); setTimeout(()=>c.style.transform='translateX(0)',240); }

/* Capture button */
btnCapture.addEventListener('click', ()=>{
  if(counting) return;
  counting=true; btnCapture.disabled=true; btnCapture.style.opacity=0;

  let t=5; showCounter(t);
  const tick = setInterval(()=>{
    t--;
    if(t>0){
      counter.style.transform='translate(-50%,-50%) scale(1.18) rotate(-2deg)';
      setTimeout(()=>counter.style.transform='translate(-50%,-50%) scale(1) rotate(0)',140);
      counter.textContent=t; cameraShake();
    } else {
      clearInterval(tick); counter.textContent='✓';
      flash.style.opacity=0.95; flash.classList.remove('hidden');
      setTimeout(()=>{flash.style.opacity=0; flash.classList.add('hidden');},120);
      setTimeout(()=>{ hideCounter(); captureFrame(); },180);
    }
  },1000);
});

/* Capture frame -> produce blob */
async function captureFrame(){
  try{
    const canvas=document.createElement('canvas');
    canvas.width = video.videoWidth || 1280;
    canvas.height = video.videoHeight || 720;
    const ctx=canvas.getContext('2d');
    // mirror so user sees mirrored preview saved correctly (we mirrored video previously)
    ctx.translate(canvas.width,0); ctx.scale(-1,1);
    ctx.drawImage(video,0,0,canvas.width,canvas.height);

    // We want to compress/rescale before sending: create a resized blob (JPEG)
    const originalBlob = await new Promise(res => canvas.toBlob(res, 'image/png'));
    if(!originalBlob){ throw new Error('Error capturando foto'); }

    // Resize & compress to reduce payload
    const processedBlob = await resizeAndCompressBlob(originalBlob, { maxWidth: 1024, quality: 0.82 });
    if(!processedBlob){ throw new Error('Error procesando imagen'); }

    capturedBlob = processedBlob;
    showScene('processing');

    const ok = await generateLegoOnBackend(processedBlob);
    if(ok){
      legoPreview.src = legoDataUrl;
      nameInput.value = '';
      btnSave.disabled = true;
      showScene('preview');
      nameInput.focus();
    } else {
      alert('Error generando la imagen. Intentá nuevamente');
      showScene('webcam');
      btnCapture.disabled=false; btnCapture.style.opacity=1;
    }
    counting=false;
  }catch(e){
    console.error(e);
    alert('Error al capturar: ' + (e?.message || e));
    counting=false; btnCapture.disabled=false; btnCapture.style.opacity=1;
  }
}

/* Resize & compress helper */
async function resizeAndCompressBlob(blob, { maxWidth = 1024, quality = 0.82 } = {}) {
  // create ImageBitmap to draw scaled
  const bitmap = await createImageBitmap(blob);
  let targetWidth = bitmap.width;
  let targetHeight = bitmap.height;
  if (bitmap.width > maxWidth) {
    const scale = maxWidth / bitmap.width;
    targetWidth = Math.round(bitmap.width * scale);
    targetHeight = Math.round(bitmap.height * scale);
  }

  const c = new OffscreenCanvas ? new OffscreenCanvas(targetWidth, targetHeight) : document.createElement('canvas');
  c.width = targetWidth;
  c.height = targetHeight;
  const ctx = c.getContext('2d');
  ctx.drawImage(bitmap, 0, 0, targetWidth, targetHeight);

  // toBlob as JPEG compressed
  const blobPromise = new Promise((resolve) => {
    if (c.convertToBlob) {
      // OffscreenCanvas
      c.convertToBlob({ type: 'image/jpeg', quality }).then(resolve).catch(()=>resolve(null));
    } else {
      c.toBlob((b) => resolve(b), 'image/jpeg', quality);
    }
  });
  const outBlob = await blobPromise;
  bitmap.close?.();
  return outBlob;
}

/* FileReader -> base64 robust */
async function blobToBase64(blob){
  return new Promise((resolve, reject) => {
    try {
      const reader = new FileReader();
      reader.onload = () => {
        if (typeof reader.result === 'string') {
          const parts = reader.result.split(',');
          if (parts.length >= 2) resolve(parts[1]);
          else reject(new Error('Invalid data URL'));
        } else {
          reject(new Error('FileReader did not return a string'));
        }
      };
      reader.onerror = (err) => reject(err || new Error('FileReader error'));
      reader.readAsDataURL(blob);
    } catch (e) { reject(e); }
  });
}

/* dataURL -> Blob helper */
function dataUrlToBlob(dataUrl) {
  const parts = dataUrl.split(',');
  if(parts.length !== 2) throw new Error('Invalid data URL');
  const meta = parts[0];
  const b64 = parts[1];
  const m = meta.match(/data:(.*?);base64/);
  const mime = m ? m[1] : 'image/png';
  const binary = atob(b64);
  const len = binary.length;
  const u8 = new Uint8Array(len);
  for (let i = 0; i < len; i++) u8[i] = binary.charCodeAt(i);
  return new Blob([u8], { type: mime });
}

/* ========== Call serverless ========== */
async function generateLegoOnBackend(photoBlob){
  try{
    // convert to base64 (without the data: prefix)
    const base64 = await blobToBase64(photoBlob).catch(e => { throw new Error('Error convirtiendo imagen: ' + e.message); });

    // send to our Netlify function which proxies to Wordware and returns data_url
    const controller = new AbortController();
    const t = setTimeout(()=>controller.abort(), 60_000); // 60s timeout for whole operation
    let resp;
    try {
      resp = await fetch('/.netlify/functions/generate-lego', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ image_base64: base64 }),
        signal: controller.signal
      });
    } catch (e) {
      clearTimeout(t);
      throw new Error('No se pudo contactar al servidor: ' + (e.message || e.name));
    }
    clearTimeout(t);

    if (!resp.ok) {
      const txt = await resp.text().catch(()=>null);
      throw new Error('Server returned error: ' + resp.status + ' — ' + (txt || 'no details'));
    }

    const json = await resp.json().catch(()=>null);
    if(!json){
      throw new Error('Respuesta inválida del servidor');
    }

    // Prefer data_url (base64) to avoid CORS. If only result_url present, still try to use it,
    // but note: may fail due to CORS if client fetches it directly.
    const dataUrl = json.data_url || null;
    const resultUrl = json.result_url || null;

    if (dataUrl) {
      legoDataUrl = dataUrl;
      return true;
    } else if (resultUrl) {
      // fallback: try to fetch the image from resultUrl (may fail due to CORS)
      try {
        const r2 = await fetch(resultUrl);
        if (!r2.ok) throw new Error('HTTP ' + r2.status);
        const blob = await r2.blob();
        // create data URL locally
        const localDataUrl = await new Promise((res, rej) => {
          const reader = new FileReader();
          reader.onload = () => res(reader.result);
          reader.onerror = (e) => rej(e);
          reader.readAsDataURL(blob);
        });
        legoDataUrl = localDataUrl;
        return true;
      } catch (err) {
        console.error('Fallo al intentar descargar result_url desde cliente (probable CORS):', err);
        throw new Error('No se pudo obtener la imagen final (CORS o URL inaccesible).');
      }
    } else {
      throw new Error('El servidor no devolvió data_url ni result_url');
    }
  }catch(err){
    console.error('generateLegoOnBackend error:', err);
    return false;
  }
}

/* ========== Save logic (download) ========== */
btnSave.addEventListener('click', ()=>{
  if(!legoDataUrl){ alert('No hay imagen para guardar'); return; }
  let name = (nameInput.value || '').trim();
  if(!name){ alert('Ingresá un nombre para tu archivo'); nameInput.focus(); return; }

  name = name.replace(/[^a-z0-9_\-]/gi,'_').toLowerCase();

  try {
    const blob = dataUrlToBlob(legoDataUrl);
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = name + '.png';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    finalPreview.src = legoDataUrl;
    cameraShake();
    startConfetti();
    showScene('final');
  } catch (e) {
    console.error(e);
    alert('Error preparando la descarga: ' + (e.message || e));
  }
});

// enable/disable save based on name input
nameInput.addEventListener('input', ()=> {
  btnSave.disabled = !nameInput.value.trim();
});

/* Retake & final */
btnRetake.addEventListener('click', ()=>{
  if(legoDataUrl) legoDataUrl = null;
  if(legoBlob) { URL.revokeObjectURL(legoBlob); legoBlob = null; }
  capturedBlob = null;
  btnCapture.disabled=false; btnCapture.style.opacity=1;
  showScene('webcam');
});

btnFinal.addEventListener('click', ()=> {
  const c=document.getElementById('card'); c.style.transition='transform .5s ease, opacity .45s ease'; c.style.transform='scale(.92) translateY(-24px) rotate(-2deg)'; c.style.opacity=0; setTimeout(()=>window.location.href='index.html',520);
});

/* Confetti */
function startConfetti(){
  const count=48;
  for(let i=0;i<count;i++){
    const el=document.createElement('div'); el.className='confetti';
    el.style.left=(10+Math.random()*80)+'%'; el.style.top=(-5-Math.random()*10)+'vh';
    const w=8+Math.random()*12; el.style.width=w+'px'; el.style.height=(w*0.6)+'px';
    el.style.background=`hsl(${Math.random()*360},80%,60%)`;
    el.style.transform=`rotate(${Math.random()*360}deg)`;
    document.body.appendChild(el);
    const anim=el.animate([{transform:`translateY(0) rotate(${Math.random()*360}deg)`,opacity:1},
                           {transform:`translateY(80vh) rotate(${Math.random()*900}deg)`,opacity:0.1}],
                           {duration:1600+Math.random()*900,easing:'cubic-bezier(.2,.6,.3,1)'});
    anim.onfinish=()=>el.remove();
  }
}
</script>
</body>
</html>
